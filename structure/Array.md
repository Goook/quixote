## 数据结构之数组

什么是数组？
>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，
来存储一组具有相同类型的数据(在Python中列表可以存储不同的数据）。
线性表：数组、链表、队列、栈 非线性表：树 图
由于数组是连续的内存空间、相同的数据，所以数组可以随机访问，
但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作


#### 数组如何实现下标随机访问。 
我们知道，数组a所在地址其实是数组的首地址。而在Python中。
列表b所存储的值就是列表b的首地址。当数组通过索引随机访问位置i所存储的元素时。
会按照如下寻址公式

`a[i]_address = base_address + i * data_type_size`

**二维数组的寻址方式**
`a[i]_address = base_address + (i*n +j )*data_type_size`

#### 低效的插入和删除
由于数组为了保证内存地址连续，因此数组的插入和删除都比较低效
1. 当数组进行插入操作时，随机插入某个位置时，由于要保证数据一致性，
因此要将插入位置往后的元素整体向后挪一位，插入的时间复杂度为O(n)。
平均时间复杂度也为O(n)，优化策略：若数组元素无序，
可以将原始数据放置在末尾，将待插入元素放置在原位置。使时间复杂度降为O(1)
2. 删除元素时，由于保证内存地址连续，因此要将后面位置的元素整体
向前挪一位，平均时间复杂度O(n)




#### 数组的优势和缺陷
* 数组的优势： 随机访问的时间复杂度为O(1)
* 数组的缺点： 
  * 低效的插入和删除，
  * 连续的内存存储导致数组拓展大小时耗费时间。


#### 数组和链表的区别。
* 追加： 数组O(1), 链表O(1)
* 插入： 数组O(n), 链表O(1)
* 删除： 数组O(n), 链表O(1)
* 访问： 数组O(1), 链表O(n)


#### 警惕数组的访问越界问题
```
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}

```
由于i紧随其后被分配地址，因此a[3]会覆盖i的初始值，代码会无限循环。
用C语言循环越界访问的例子说明访问越界的bug，如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存（即先分配的在高地址）
，那么内存中的i将会被置为0，则为死循环永远出不去。

#### 容器能否完全替代数组？
相比于数字，容器封装了很多操作，并支持自动动态扩容。
一旦超过一定大小，扩容时比较耗内存，因为涉及到内存申请和数据搬移。

数组适合的场景：
1）	Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组
2）	若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组
3）	表示多维数组时，数组往往更加直观。
4）	业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。

总的来说，容器封装强，可动态扩容，但速度慢，适合复杂的业务场景
数组封装少，不可扩容，但速度快，适合要求性能的场景

#### 为什么数组从0开始编号？

由于数组下标代表的其实时某个位置相对于首地址的偏移量，那么a[0]就
代表数组a[0]相对于首地址偏移0个位置。如果从1开始编号。那么a[i]的
寻址公式将如下

`a[i]_address = base_address + (i-1)*data_type_size`

相对于从0开始编号，这总计数方式多进行一次运算。



